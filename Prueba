Para solucionar el problema del desplazamiento al editar una fila en el `DataTable`, debes asegurarte de que el `body` de la página no se desplace mientras el modal de edición está abierto. Puedes hacer esto añadiendo una clase CSS que desactive el desplazamiento y manejando esta clase en los métodos de edición. Aquí está la actualización del código relevante para incorporar esta solución:

1. **CSS para Desactivar el Desplazamiento:**

   Asegúrate de agregar esta clase CSS en tu archivo de estilos:

   ```css
   /* styles.css */
   body.no-scroll {
     overflow: hidden;
   }
   ```

2. **Actualizar el Código del Componente para Manejar el Desplazamiento:**

   Modifica el código en los métodos `startEdit`, `cancelEdit` y `saveChanges` para añadir y eliminar la clase `no-scroll` al `body` según sea necesario:

   ```jsx
   import React, { useState, useEffect } from "react";
   import axios from "axios";
   import styled from "styled-components";
   import { ButtonGroup, Button, StyledInput } from "./Estilos.jsx";
   import { FaSearch, FaPlus, FaUndo } from "react-icons/fa";

   const StyledDataTable = styled(DataTable)`
     /* Tus estilos personalizados aquí */
   `;

   const Paises = () => {
     const [editMode, setEditMode] = useState(false);
     const [editedRow, setEditedRow] = useState(null);
     const [errors, setErrors] = useState({});
     const [loading, setLoading] = useState(false);
     const [records, setRecords] = useState([]);
     const [filters, setFilters] = useState({ N_Pais: "" });
     const [showModal, setShowModal] = useState(false);
     const [modalValues, setModalValues] = useState({ pais: "" });

     useEffect(() => {
       // Aquí deberías cargar tus datos iniciales
     }, []);

     const startEdit = (row) => {
       setEditMode(row.id);
       setEditedRow(row);
       document.body.classList.add('no-scroll'); // Desactiva el desplazamiento
     };

     const cancelEdit = () => {
       setEditMode(null);
       setEditedRow(null);
       document.body.classList.remove('no-scroll'); // Reactiva el desplazamiento
     };

     const saveChanges = async (id) => {
       try {
         const updateRow = {
           ...editedRow,
         };
     
         // Verificar si el país ya existe
         if (editedRow && editedRow.N_Pais) {
           console.log("Checking if country exists...");
           const response = await axios.get(
             `http://localhost:3000/pais?N_Pais=${editedRow.N_Pais}`
           );
     
           console.log("Response:", response.data);
     
           if (
             response.data.some(
               (pais) =>
                 pais.N_Pais.toLowerCase() === editedRow.N_Pais.toLowerCase()
             )
           ) {
             const errorNotification = document.createElement("div");
             errorNotification.className = "error-notification";
             errorNotification.innerHTML = `
               <span class="error-icon">!</span>
               <span class="error-message">
                 El País que intenta actualizar ya existe en la base de datos.
                 Por favor, ingrese una país diferente.
               </span>
             `;
             document.body.appendChild(errorNotification);
     
             // Ocultar la notificación después de 2 segundos
             setTimeout(() => {
               errorNotification.remove();
             }, 2000);
             return;
           }
         } else {
           setErrors({ N_Pais: "El campo país no puede estar vacío" });
           return;
         }
     
         // Revisar si el pais ya existe en la base de datos
         const existingCountry = records.find(
           (row) => row.N_Pais.toLowerCase() === editedRow.N_Pais.toLowerCase()
         );
     
         if (existingCountry && existingCountry.id !== id) {
           setErrors({ N_Pais: "El país ya está registrado" });
           return;
         }
     
         // Obtener el valor original del campo
         const originalRow = records.find((row) => row.id === id);
     
         await axios.put(`http://localhost:3000/pais/${id}`, updateRow);
     
         // Obtener el índice del país editado
         const editedIndex = records.findIndex((row) => row.id === id) + 1;
     
         // Guardar el campo original y el campo nuevo en la auditoría
         const auditoriaData = {
           Campo_Original: `- País: ${originalRow.N_Pais}`,
           Campo_Nuevo: `- País: ${editedRow.N_Pais}`,
           Tabla: 'Paises',
           Accion: 2,
           ID_Usuario: userId,
           N: editedIndex
         };
     
         await axios.post('http://localhost:3000/auditoria', auditoriaData);
     
         const updatedRecords = records.map((row) =>
           row.id === id ? { ...editedRow } : row
         );
     
         setRecords(updatedRecords);
         setEditedRow(null);
         setEditMode(null);
     
         // Notificación de datos actualizados
         const toastElement = document.createElement("div");
         toastElement.className = "toast-notification";
         toastElement.innerHTML = "País actualizado con éxito!";
     
         document.body.appendChild(toastElement);
     
         // Ocultar la notificación después de 1 segundo
         setTimeout(() => {
           toastElement.remove();
           window.location.reload(); // Recargar la página después de 1 segundo
         }, 1000);
       } catch (error) {
         console.error("Error al guardar los cambios", error);
       } finally {
         document.body.classList.remove('no-scroll'); // Reactiva el desplazamiento
       }
     };

     const handleEditChange = (event, field) => {
       const { value } = event.target;
       setEditedRow((prevState) => ({
         ...prevState,
         [field]: value,
         ...(field === "ID_Pais" && {
           N_Pais: pais.find((p) => p.id === parseInt(value)).N_Pais,
         }),
       }));
       validateInput(field, value); // Validación de los campos a editar
     };

     const validateInput = (field, value) => {
       let newErrors = { ...errors };
       if (field === "pais") {
         if (!value.trim()) {
           newErrors.pais = "El campo País es obligatorio";
         } else if (!/^[a-zA-ZÑñ\s]+$/.test(value)) {
           newErrors.pais =
             "El campo País solo acepta letras y espacios en blanco";
         } else {
           newErrors.pais = "";
         }
       }
       setErrors(newErrors);
     };

     const deleteRow = (id) => {
       axios
         .get(`/Datosdependientes/${id}`)
         .then((response) => {
           if (response.data.hasDependencies) {
             alert(
               "No se puede eliminar este registro porque tiene dependencias en otros registros."
             );
           } else {
             axios
               .delete(`/delete/${id}`)
               .then((response) => {
                 // Actualiza la lista de filas después de eliminar una fila
                 setRows(rows.filter((row) => row.id !== id));
               })
               .catch((error) => console.error(error));
           }
         })
         .catch((error) => console.error(error));
     };

     const columns = [
       {
         name: "N°",
         selector: (row, index) => (currentPage - 1) * rowsPerPage + index + 1,
         sortable: true,
         minWidth: "50px",
         maxWidth: "100px",
       },
       {
         name: "País",
         selector: (row) => row.id,
         sortable: true,
         minWidth: "200px",
         maxWidth: "50px",
         cell: (row) =>
           editMode && editedRow?.id === row.id ? (
             <StyledInput
               type="text"
               value={editedRow.N_Pais}
               onChange={(e) => handleEditChange(e, "N_Pais")}
               onKeyPress={(e) => {
                 if (!/[a-zA-ZñÑáéíóúÁÉÍÓÚ]/.test(e.key)) {
                   e.preventDefault();
                 }
               }}
             />
           ) : (
             <div>{row.N_Pais}</div>
           ),
       },
       {
         name: "Acciones",
         cell: (row) =>
           editMode === row.id ? (
             <ButtonGroup>
               <Button
                 type="button"
                 className="btn btn-outline-success"
                 onClick={() => saveChanges(row.id)}
               >
                 Guardar
               </Button>
               <Button
                 type="button"
                 className="btn btn-outline-danger"
                 onClick={cancelEdit}
               >
                 Cancelar
               </Button>
             </ButtonGroup>
           ) : (
             <ButtonGroup>
               <Button
                 type="button"
                 className="btn btn-outline-primary"
                 onClick={() => startEdit(row)}
               >
                 Editar
               </Button>
               <Button
                 type="button"
                 className="btn btn-outline-danger"
                 onClick={() => {
                   if (
                     window.confirm(
                       "¿Estás seguro que deseas eliminar este registro?"
                     )
                   ) {
                     deleteRow(row.id);
                   }
                 }}
              