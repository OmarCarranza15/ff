Para asegurar que los campos `Campo_Original` y `Campo_Nuevo` se muestren correctamente y no como `[object Object]`, debes asegurarte de que los datos en estas columnas sean cadenas de texto. Si estos campos contienen objetos, debes convertirlos a cadenas antes de mostrarlos.

Aquí está el código actualizado para la función `formatFieldWithLineBreaks` y cómo deberías usarla en las columnas:

1. **Actualiza la función `formatFieldWithLineBreaks` para manejar objetos y cadenas:**

   ```jsx
   function formatFieldWithLineBreaks(field) {
     // Verifica si 'field' es null o undefined
     if (field == null) {
       return ""; // O algún valor por defecto adecuado
     }
     
     // Convierte el objeto a una cadena JSON si 'field' es un objeto
     const fieldString = typeof field === 'object' ? JSON.stringify(field) : field;
     
     return fieldString.split("\n").map((line, index) => (
       <React.Fragment key={index}>
         {line}
         <br />
       </React.Fragment>
     ));
   }
   ```

   Esta función asegura que si `field` es un objeto, se convierta en una cadena JSON antes de procesarlo. Esto previene la visualización de `[object Object]`.

2. **Actualiza las columnas `Campo Original` y `Campo Nuevo` para usar esta función:**

   En la definición de tus columnas, asegúrate de usar `formatFieldWithLineBreaks` para la visualización:

   ```jsx
   const columns = [
     // Otras columnas...
     {
       name: "Campo Original",
       selector: (row) => row.Campo_Original,
       sortable: true,
       minWidth: "200px",
       maxWidth: "500px",
       cell: (row) =>
         editedRow && editedRow.id === row.id ? (
           <input
             type="text"
             value={editedRow.Campo_Original}
             style={{
               padding: "8px",
               fontSize: "12px",
               borderRadius: "5px",
             }}
           />
         ) : (
           <div>{formatFieldWithLineBreaks(row.Campo_Original)}</div>
         ),
     },
     {
       name: "Campo Nuevo",
       selector: (row) => row.Campo_Nuevo,
       sortable: true,
       minWidth: "200px",
       maxWidth: "500px",
       cell: (row) =>
         editedRow && editedRow.id === row.id ? (
           <input
             type="text"
             value={editedRow.Campo_Nuevo}
             style={{
               padding: "8px",
               fontSize: "12px",
               borderRadius: "5px",
             }}
           />
         ) : (
           <div>{formatFieldWithLineBreaks(row.Campo_Nuevo)}</div>
         ),
     },
     // Otras columnas...
   ];
   ```

Este enfoque asegurará que el contenido de `Campo_Original` y `Campo_Nuevo` se muestre correctamente como texto y no como `[object Object]`. Verifica tus datos y asegúrate de que se procesen adecuadamente antes de la visualización.