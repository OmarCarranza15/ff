Para resolver los problemas con la edición de checkboxes y mejorar el diseño, aquí tienes algunos ajustes específicos que puedes hacer:

### 1. **Ajustes en el `handleEditChange`**

Para que los checkboxes se actualicen correctamente, asegúrate de que `handleEditChange` maneje tanto la edición de texto como el estado del checkbox. Modifica `handleEditChange` para manejar los checkboxes correctamente:

```javascript
const handleEditChange = (event, field) => {
  const { value, type, checked } = event.target;
  if (type === "checkbox") {
    setEditedRow((prevState) => ({
      ...prevState,
      [field]: checked,
    }));
  } else {
    setEditedRow((prevState) => ({
      ...prevState,
      [field]: value,
    }));
  }
};
```

### 2. **Actualizar el Diseño de los Checkboxes**

Para mejorar el aspecto de los checkboxes, puedes utilizar bibliotecas como [Styled Components](https://styled-components.com/) o CSS para personalizar los estilos. Aquí te muestro cómo puedes hacerlo usando `styled-components`:

```javascript
import styled from 'styled-components';

const Checkbox = styled.input`
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 4px;
  border: 2px solid #007bff;
  background-color: ${(props) => (props.checked ? '#007bff' : '#fff')};
  cursor: pointer;
  position: relative;
  outline: none;

  &:checked::after {
    content: '✓';
    color: white;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 14px;
  }

  &:hover {
    border-color: #0056b3;
  }
`;

const CustomCheckbox = ({ checked, onChange }) => (
  <Checkbox
    type="checkbox"
    checked={checked}
    onChange={onChange}
  />
);
```

Luego, en tu componente, utiliza `CustomCheckbox` en lugar de `<input type="checkbox" />`:

```javascript
const columns = [
  {
    name: "Permiso de Insertar",
    selector: (row) => row.Insertar,
    sortable: true,
    minWidth: "170px",
    maxWidth: "50px",
    cell: (row) =>
      editMode && editedRow?.id === row.id ? (
        <CustomCheckbox
          checked={editedRow.Insertar}
          onChange={(e) => handleEditChange(e, "Insertar")}
        />
      ) : (
        <CustomCheckbox
          checked={row.Insertar === 1}
          disabled
        />
      ),
  },
  {
    name: "Permiso de Editar",
    selector: (row) => row.Editar,
    sortable: true,
    minWidth: "170px",
    maxWidth: "50px",
    cell: (row) =>
      editMode && editedRow?.id === row.id ? (
        <CustomCheckbox
          checked={editedRow.Editar}
          onChange={(e) => handleEditChange(e, "Editar")}
        />
      ) : (
        <CustomCheckbox
          checked={row.Editar === 1}
          disabled
        />
      ),
  },
];
```

### 3. **Actualizar `SaveModal` y `saveChanges`**

Asegúrate de que `SaveModal` y `saveChanges` conviertan correctamente los valores booleanos a enteros para el backend:

```javascript
const SaveModal = async () => {
  const newErrors = { pais: "", rolusuario: "" };
  
  if (!modalValues.Paises.length) {
    newErrors.pais = "El campo Pais es obligatorio";
  }

  if (!modalValues.N_Rol.trim()) {
    newErrors.rolusuario = "El campo Rol es obligatorio";
  }
  setErrors(newErrors);

  if (Object.values(newErrors).every((error) => error === "")) {
    try {
      const response = await axios.get(`http://localhost:3000/rolusuario`);
      const rolusuarioExists = response.data.some(
        (rolusuario) =>
          rolusuario.N_Rol.toLowerCase() ===
          modalValues.N_Rol.toLowerCase()
      );
      if (rolusuarioExists) {
        setErrors({ rolusuario: "El Rol ya existe" });
        return;
      }

      const newRolUsuario = {
        N_Rol: modalValues.N_Rol,
        Des_Rol: modalValues.Des_Rol,
        Fec_Creacion: new Date(),
        Insertar: modalValues.Insertar ? 1 : 2,
        Editar: modalValues.Editar ? 1 : 2,
        Paises: modalValues.Paises.join(","),
      };
      
      const insertResponse = await axios.post(
        `http://localhost:3000/rolusuario`,
        newRolUsuario
      );
      const updatedRecords = [
        ...records,
        {
          id: insertResponse.data.id,
          N_Rol: newRolUsuario.N_Rol,
          Des_Rol: newRolUsuario.Des_Rol,
          Fec_Creacion: newRolUsuario.Fec_Creacion,
          Insertar: newRolUsuario.Insertar,
          Editar: newRolUsuario.Editar,
          Paises: modalValues.Paises.map(id => pais.find(a => a.id === id)?.N_Pais),
        },
      ];

      setRecords(updatedRecords);
      setShowModal(false); 
      setModalValues({ N_Rol: "", Des_Rol: "", Paises: [] }); 
      window.location.reload();
    } catch (error) {
      console.error("Error al insertar un nuevo Rol:", error);
    }
  }
};

const saveChanges = async (id) => {
  try {
    const updateRow = {
      ...editedRow,
      Insertar: editedRow.Insertar ? 1 : 2,
      Editar: editedRow.Editar ? 1 : 2,
      Paises: editedRow.Paises.join(", "),
    };

    await axios.put(`http://localhost:3000/rolusuario/${id}`, updateRow);

    const updatedRecords = records.map((row) =>
      row.id === id ? { ...updateRow } : row
    );

    setRecords(updatedRecords);
    setEditedRow(null);
    setEditMode(null);

    console.log("Cambios guardados correctamente");
    window.location.reload();
  } catch (error) {
    console.error("Error al guardar los cambios", error);
  }
};
```

### 4. **Actualizar el Estilo de los Checkboxes en el Modal**

Aplica los mismos estilos personalizados a los checkboxes en el modal:

```javascript
<CustomCheckbox
  checked={modalValues.Insertar}
  onChange={(e) => handleModalChange(e, "Insertar")}
/>
<CustomCheckbox
  checked={modalValues.Editar}
  onChange={(e) => handleModalChange(e, "Editar")}
/>
```

Con estos cambios, deberías poder editar los checkboxes y mejorar su apariencia en la tabla y el modal.